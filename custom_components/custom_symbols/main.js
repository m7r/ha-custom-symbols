const DOMAIN="custom_symbols",ICON_STORE={},CONFIG={"-":"order",":":"color","#":"mode","%":"breakPoint",b:{prefix:"monochrome"},v:{prefix:"monochrome",fade:.6},h:{prefix:"hierarchical",secondary:"opacity: 0.5",tertiary:"opacity: 0.2",fade:.7},p:{prefix:"hierarchical",primary:"fill: var(--cs-primary, currentColor)",secondary:"fill: var(--cs-secondary, var(--primary-color, #03a9f4))",tertiary:"fill: var(--cs-tertiary, var(--accent-color, #ff9800))",fade:.6},m:{prefix:"multicolor",primary:"fill: var(--cs-primary, currentColor)",secondary:"fill: var(--cs-base, var(--primary-text-color, #000));",tertiary:"fill: var(--cs-base, var(--primary-text-color, #000)); opacity: 0.3",useFill:!0,fade:.6}},noop=()=>{},fetchJSON=async t=>(await fetch(t)).json(),compareOrder=(t,e)=>t.order>e.order,getPath=t=>t.path,combinePaths=t=>t.map((t=>t.getAttribute("d"))).join(" "),getOption=(t,e)=>t.split(/([-:#%])/).reduce(((t,e,o,r)=>{const c=CONFIG[e],a=r[o+1];return c&&(t[c]=a),t}),e),extractMode=t=>e=>Array.from(e.classList).filter((e=>e.startsWith(t.prefix))).map((t=>getOption(t,{path:e}))),makeDynamic=(t,e)=>{const o=[];return t.map((t=>{if(e<=t.breakPoint){const e="clear"==t.mode,r={...t,color:t.color+"Fade",fade:e-2};if(!e)return r;o.push(r)}return t})).concat(o)},mergeColors=t=>t.reduce(((t,e)=>{const o=e.color??null;return t.color!==o&&(t.color=o,t.push(t.current=[])),t.current.push(e),t}),[]),createStyle=(t,e)=>{const o=t[t.length-1];let r=[];if(o.color){const t=o.color.replace("Fade",""),c=e.useFill&&(o.path.getAttribute("fill")||"#000"),a=e[t]||c&&`fill: var(--cs-${t}, ${c.slice(0,7)})`;a&&r.push(a),c?.length>7&&r.push("opacity: "+parseInt(c.slice(7,9),16)/255)}return o.fade&&r.push(`opacity: ${Math.abs(1+o.fade+e.fade)}`),r.join("; ")},preProcessIcon=async(t,e)=>{const[o,r=""]=e.split("#"),[c,a]=r.split(/(\d+)/),n=void 0!==a,s=CONFIG[c[0]]||(n?CONFIG.v:CONFIG.b);let i,l=" ",h=null;const p=await fetch(`/${DOMAIN}/icon/${t}/${o}.svg`),m=await p.text(),u=(new DOMParser).parseFromString(m,"image/svg+xml");if(!u||"svg"!=u.documentElement.nodeName)return{};const d=u.documentElement,f=Array.from(d.querySelectorAll("path"));if(i=d.getAttribute("viewBox"),s){let t=f.flatMap(extractMode(s)).sort(compareOrder);n&&(t=makeDynamic(t,a)),t=mergeColors(t),h=t.map((t=>{const e=document.createElementNS("http://www.w3.org/2000/svg","path"),o=createStyle(t,s);return o&&e.setAttribute("style",o),e.setAttribute("d",combinePaths(t.map(getPath))),e})),s.primary||1!=h.length||(l=h[0].getAttribute("d"),h=null)}return" "!==l||h||(l=combinePaths(f)),{path:l,viewBox:i,nodes:h}};async function getIconPath(t){const e=document.createElement("ha-icon");return e.icon=t,await e._loadIcon(),e._path}async function getIconPathEntry([t,e]){const o=await getIconPath(t);return o||console.error(`Custom Symbols: Invalid icon ${t}`),o&&[o,await getIcon(...e.split(":"))]}async function createPathMap(t){const e=await Promise.all(Object.entries(t).map(getIconPathEntry));return Object.fromEntries(e.filter(Boolean))}const getIcon=async(t,e)=>{const o=`${t}:${e}`;return ICON_STORE[o]||(ICON_STORE[o]=preProcessIcon(t,e)),ICON_STORE[o]},getIconList=async t=>fetchJSON(`/${DOMAIN}/list/${t}`);"customIcons"in window||(window.customIcons={}),window.customIcons.cs={getIcon:t=>getIcon("cs",t),getIconList:()=>getIconList("cs")},Promise.all([customElements.whenDefined("ha-icon"),customElements.whenDefined("ha-svg-icon")]).then((async()=>{const t=await fetchJSON(`/${DOMAIN}/replace/cs`),e=await createPathMap(t),o=customElements.get("ha-icon"),r=customElements.get("ha-svg-icon"),c=Object.getOwnPropertyDescriptor(r.prototype,"path"),a=c.set;c.set=function(t){if(t in e){const o=e[t];this._viewBox_=this.viewBox,a.call(this,o.path),this.setIcon(o).catch(noop)}else this.viewBox=this._viewBox_,delete this._viewBox_,a.call(this,t),this.clearPaths().catch(noop)},Object.defineProperty(r.prototype,"path",c),r.prototype.clearPaths=async function(){await this.updateComplete;const t=this.shadowRoot.querySelector("g");for(;t?.childElementCount>1;)t.removeChild(t.lastChild);return t},r.prototype.setIcon=async function({nodes:t=[],viewBox:e=null}){const o=await this.clearPaths();null!=e&&(this.viewBox=e),t.forEach((t=>o?.appendChild(t.cloneNode(!0))))},o.prototype._setCustomPath=async function(t,e){const o=await t;if(e===this.icon)return this._path=o.path,this._viewBox=o.viewBox,o.nodes?(await this.UpdateComplete,this.shadowRoot.querySelector("ha-svg-icon")?.setIcon(o)):void 0}})).catch(console.error);